<< Oracle SQL Developer >>
명령어는 대소문자 상관없음

===============================================================

[ User 만들기 ]

DROP USER c##md CASCADE;
CREATE USER c##md IDENTIFIED BY md DEFAULT TABLESPACE users TEMPORARY TABLESPACE temp PROFILE DEFAULT;
GRANT CONNECT, RESOURCE TO c##md;
GRANT CREATE VIEW, CREATE SYNONYM TO c##md;
GRANT UNLIMITED TABLESPACE TO c##md;
ALTER USER c##md ACCOUNT UNLOCK;

===============================================================

[ 테이블 생성 ] 

기본 형태:
  create table 테이블명(
  열이름 데이터타입 제약조건,
  ...);
  ==> 제약조건은 필수는 아님. 필요에 따라 내용 추가

e.g. CREATE TABLE Book (
     bookid NUMBER(2) PRIMARY KEY,
     bookname VARCHAR2(40),
     publisher VARCHAR2(40),
     price NUMBER(8)
     );


[ on delete cascade + foreign key 설정 ]

on delete cascade 옵션이 설정되어 있어, 
newcustomer 테이블에서 어떤 고객의 레코드가 삭제되면, 
해당 고객의 모든 주문이 neworders 테이블에서도 자동으로 삭제

e.g. create table newcustomer(
     custid number primary key,
     name varchar2(40),
     address varchar2(40),
     phone varchar2(30));
    
     create table neworders(
     orderid number,
     custid number not null,
     bookid number not null,
     saleprice number,
     orderdate date,
     primary key(orderid),
     foreign key(custid) references newcustomer(custid) on delete cascade);

===============================================================

[ 테이블에 데이터 입력 ]
insert into 사용
기본 형태:
  insert into 테이블명 values(행 데이터 입력,...);

- 테이블 수정 
alter + add 사용
기본 형태:
  alter table 테이블명 add 열이름 데이터타입;
    e.g. alter table newbook add author_id number;

- 테이블 기전 제약조건 수정 
alter + modify 사용
기본 형태: 
  alter table 테이블명 modify (열이름 데이터타입 수정내용));
      e.g. alter table newbook modify (isbn varchar2(50));
           ==> alter 사용 시 테이블 안의 데이터가 모두 비워진 상태에서만 사용 가능

- 테이블 삭제 
alter + drop 사용
기본 형태:
  alter table 테이블명 drop column 테이블명;
      e.g. alter table newbook drop column author_id;

   


===============================================================

[ 데이터/테이블 선택 ]

해당 테이블 전체 뷰잉
- SELECT * FROM 테이블;
  e.g. SELECT * FROM customer;

보고싶은 내용에 대해서만 특정 테이블에서 불러와 보기
- SELECT 변수1, ..., 변수n FROM 테이블;
  e.g. SELECT publisher FROM book;

중복값 제거하여 보기
- SELECT DISTINCT 변수 FROM 테이블;
  e.g. SELECT DISTINCT publisher FROM book;

===============================================================

[ 특정 조건으로 선택 ]

조건 걸어 데이터 선택할 경우에는 where를 먼저 써줘야 함
- WHERE 조건~~~;
  e.g.  SELECT * FROM book
        WHERE price BETWEEN 10000 AND 20000;

- 조건1 AND 조건2: 조건1과 조건2에 모두 부합하는 케이스
  e.g.  SELECT bookname, price FROM book
        WHERE bookname like '축구' and price>=20000;

- 조건1 BETWEEN 조건2: 조건1과 조건2 사이에 들어가는 케이스
  e.g.  SELECT * FROM book
        WHERE price BETWEEN 10000 AND 20000;

- 변수 in ('조건1', '조건2') : 
  e.g.  SELECT * FROM book
        WHERE publisher in ('굿스포츠','대한미디어');

- union :
  e.g.  SELECT * FROM book
        WHERE publisher='굿스포츠' 
        union 
        select * from book 
        where publisher='대한미디어';



이후 세부 조건 달아줌:
- like 조건: 정확하게 '조건'과 일치하는 케이스
  e.g. SELECT bookname, publisher FROM book
       WHERE bookname LIKE '축구의 역사';

- unlike 조건: '조건'과 일치하지 않는 케이스
  e.g. SELECT bookname, publisher FROM book
       WHERE bookname UNLIKE '축구';

- %조건% : '조건'이 포함된
  e.g. SELECT bookname, publisher FROM book
       WHERE bookname LIKE '%축구%';

- 변수='조건' : 변수가 '조건'과 정확히 일치하는 경우
  e.g.  SELECT * FROM book
        WHERE (publisher='굿스포츠') or (publisher='대한미디어');

- _'문자열'% : 특정 위치에 특정 문자열을 같는 데이터 찾기
  e.g. SELECT bookname, publisher FROM book
       WHERE bookname LIKE '_구%';

- group by : 특정 조건에 맞춰 그루핑하여 뷰잉
  select 변수명1, ..., 변수명n
  from 테이블
  group by 그루핑하고 싶은 변수
    e.g. SELECT custid, COUNT(*)AS 도서수량, sum(saleprice) AS "총 판매액"
         From orders
         Group by custid;
          ==> orders 테이블에서 custid, 데이터 셀 개수, saleprice를 선택하여
              custid별로 데이터 묶는데
              saleprice는 custid별의 합계를 계산해 '총 판매액'이라는 새 변수로 넣어 제시

- having count(*) : group by 뒤에 세부 조건 붙일 때 사용
  e.g. SELECT custid, COUNT(*)AS 도서수량, sum(saleprice) AS "총 판매액"
       From orders
       Where bookid>=5
       Group by custid
       HAVING COUNT(*)>2;
       ==> 위에서 custid로 새로 정리된 데이터를 제시하는데,
           그 중 custid 별 count가 (데이터 셀 총 개수) 2 이상인 경우만 선택

=============================================================== 

[ 데이터 정렬 ]
올림차순:
  order by 변수1, ... 변수n;
  e.g. SELECT * FROM book
       order by price,bookname;
        ==>  먼저 쓰여진 변수의 기준으로 소팅되고, 
             동급이 있는 경우 그 다음 변수의 기준으로 소팅

내림차순:
  order by 변수 desc;
  e.g. SELECT * FROM book
       ORDER BY price DESC;

===============================================================

[ 계산하여 새로운 변수로 데이터 선택할 때 ]

- 합계: sum 함수 사용
  sum(변수명) as 새로운변수명
  ** as는 제외해도 됨
  e.g. select sum(saleprice) as total
       from orders;
        ==> orders 테이블에서 saleprice 변수의 데이터를 모두 더해서 
            'total'이라는 새로운 변수명으로 데이터 정리

- 평균: avg 함수 사용
  e.g. select avg(saleprice) as average
       from orders;

- 최대값: max 함수 사용
  e.g. select max(saleprice) as maximum
       from orders;

- 최소값: min 함수 사용
  e.g. select min(saleprice) as minimum
       from orders;

===============================================================

[ 다른 테이블에 있는 데이터들 선택하여 함께 보기 ]
join 을 쓸 수도 있고 
"테이블명.변수명" + where 로 불러와 출력도 가능

- "테이블명.변수명" + where :
  e.g. select customer.name, orders.custid, sum(orders.saleprice) as "총 판매액"
       from orders, customer
       where orders.custid=2 and orders.custid=customer.custid
       group by customer.name, orders.custid;

  e.g. select name, saleprice
       from customer, orders
       where customer.custid=orders.custid;

  e.g. select C.name, B.bookname
       from customer C, book B, orders O
       where C.custid=O.custid and O.bookid=B.bookid;

** 두 테이블에서 설렉해서 뽑을 때 양쪽 테이블의 길이가 같지 않다면, 더 없는 테이블쪽에 + 표기를 넣어서 사용
    e.g. Q. 도서를 구매하지 않은 고객을 포함하여 고객의 이름과 고객이 주문한 도서의 판매가격을 구하시오
         select C.name, O.saleprice
         from customer C, orders O
         where C.custid=O.custid(+);
         ==> orders에 빈값이 생기니까 orders 에 + 넣어줌

Join:
- 2개 이상의 테이블을 연결하여 관련된 데이터를 결합할 때 사용
- 여러가지 타입의 조인이 있음.
  1. 내부 조인 (inner join) : 
      - 교집합
        e.g. select customer.name, orders.custid, sum(orders.saleprice)
             from orders
             inner join customer on orders.custid=customer.custid
             where orders.custid=2
             group by customer.name, orders.custid;
      
        e.g. select customer.name, book.bookname
             from orders
             inner join customer on orders.custid=customer.custid
             inner join book on orders.bookid=book.bookid;


** outer join은 조인하는 여러테이블에서 한 쪽에는 데이터가 있고, 한 쪽에는 데이터가 없는 경우, 
   데이터가 있는 쪽 테이블의 내용을 모두 출력함. 
   즉, 조건에 맞지 않아도 해당하는 행을 출력하고 싶을 때 사용할 수 있음

  2. 왼쪽 외부 조인 (Left Outer Join) : 
      - 두번째 테이블에 일치하는 데이터가 없는 경우 null값이 사용
        e.g. select customer.name, orders.saleprice
             from customer
             left outer join orders on customer.custid=orders.custid;

  3. 오른쪽 외부 조인 (Right Outer Join) : 
      - 첫번째 테이블에 일치하는 데이터가 없는 경우  null 값 사용
        e.g. select customer.name,orders.saleprice
             from customer
             right outer join
             orders on customer.custid=orders.custid;

  4. Full Outer Join : 
      - 일치하는 데이터가 없는 경우 해당 테이블에서는 null값이 사용

         e.g. select customer.name, orders.saleprice
         from customer
         full outer join orders on customer.custid=orders.custid;

  5. Cross Join : 
      - 두 테이블 간의 모든 가능한 조합을 생성
        e.g. select customer.name, orders.saleprice
             from customer
             cross join orders;


===============================================================

[ 부속 질의 (subquery) ]
부속질의란 하나의 SQL 문 안에 또다른 SQL 문이 삽입되는 것
다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공할 때 사용

기본 형태: 
select 보고자하는 변수명
from 해당 변수가 속한 테이블명
where 해당 변수를 다른 테이블에서 참조할 때 사용할 수 있는 공통 변수 (select 공통 변수 from 참조 테이블);


e.g. Q. 도서를 구매할 적이 있는 고객의 이름을 검색하시오.
     select name
     from customer
     where custid in (select custid from orders);
     ==> orders 테이블에 custid가 있는 고객의 이름을 출력하라는 뜻

e.g. Q. ‘대한미디어’에서 출판한 도서를 구매한 고객의 이름을 보이시오.
     select name
     from customer
     where custid in (select custid from orders
     where bookid in (select bookid from book 
     where publisher='대한미디어'));

e.g. Q. 출판사별로 출판사의 평균 도서 가격보다 비싼 도서를 구하시오.
     select b1.bookname
     from book b1
     where b1.price>(select avg(b2.price)
     from book b2
     where b2.publisher=b1.publisher);
     ==> 동일 테이블 내에서 데이터를 가져오는데, 가져올 때 2개로 나눠서 쿼리를 정리함
         bookname을 가져올 b1과 price 조건을 걸 b2

e.g. Q. 도서를 주문하지 않은 고객의 이름을 보이시오.
     select name 
     from customer 
     where custid not in (select custid from orders);


===============================================================

[ to_date ]

to_date('2024-05-20','YYYY-MM-DD')
to_date('2024-05-20 15:45:30','YYYY-MM-DD HH24:MI:SS')



